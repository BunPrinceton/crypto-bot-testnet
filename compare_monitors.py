#!/usr/bin/env python3
"""
Quick comparison script to show polling vs WebSocket monitors
Demonstrates the advantages of real-time WebSocket data
"""

print("="*80)
print("CRYPTO ARBITRAGE BOT - Monitor Comparison")
print("="*80)
print()

print("POLLING MONITOR (src/price_monitor.py)")
print("-" * 80)
print("How it works:")
print("  - Uses CCXT library to fetch prices via REST API")
print("  - Polls exchanges every 10 seconds")
print("  - Makes separate HTTP requests for each exchange")
print()
print("Pros:")
print("  ✓ Simple to implement")
print("  ✓ Works with any exchange CCXT supports")
print("  ✓ Less complex code")
print()
print("Cons:")
print("  ✗ Data is stale (up to 10 seconds old)")
print("  ✗ Misses price movements between polls")
print("  ✗ Higher API usage (can hit rate limits)")
print("  ✗ No data logging/persistence")
print("  ✗ Arbitrage opportunities may be missed")
print()

print("\n" + "="*80)
print("WEBSOCKET MONITOR (src/websocket_monitor.py)")
print("-" * 80)
print("How it works:")
print("  - Maintains persistent WebSocket connections")
print("  - Receives price updates in real-time (milliseconds)")
print("  - Uses async/await for concurrent connections")
print()
print("Pros:")
print("  ✓ Real-time data (instant price updates)")
print("  ✓ Catches every price movement")
print("  ✓ Lower API usage (single connection per exchange)")
print("  ✓ Automatic data logging (CSV + JSON)")
print("  ✓ Better arbitrage detection")
print("  ✓ Shows data freshness indicators")
print()
print("Cons:")
print("  ✗ More complex code (async/await)")
print("  ✗ Need to handle connection errors")
print("  ✗ Requires WebSocket library")
print()

print("\n" + "="*80)
print("DATA COMPARISON")
print("-" * 80)
print()
print("Polling Monitor:")
print("  - Updates: Every 10 seconds")
print("  - Precision: ~10 second intervals")
print("  - Data logged: None")
print()
print("WebSocket Monitor:")
print("  - Updates: Real-time (as fast as exchange sends)")
print("  - Precision: Sub-second (100-500ms typical)")
print("  - Data logged: CSV (all prices) + JSON (arbitrage)")
print()

print("\n" + "="*80)
print("EXAMPLE: Catching Arbitrage Opportunities")
print("-" * 80)
print()
print("Scenario: BTC price spike on Coinbase")
print()
print("Polling Monitor:")
print("  00:00 - Fetch prices: BTC = $100,000 everywhere")
print("  00:05 - Price spikes to $100,500 on Coinbase")
print("  00:10 - Fetch prices: BTC = $100,000 (spike missed!)")
print("  Result: Arbitrage opportunity MISSED")
print()
print("WebSocket Monitor:")
print("  00:00 - Streaming prices: BTC = $100,000 everywhere")
print("  00:05 - Real-time update: Coinbase BTC = $100,500")
print("  00:05 - ARBITRAGE DETECTED! 0.5% opportunity")
print("  00:05 - Logged to arbitrage_TIMESTAMP.json")
print("  Result: Arbitrage opportunity CAUGHT")
print()

print("\n" + "="*80)
print("RECOMMENDATION FOR PRODUCTION")
print("-" * 80)
print()
print("Use WebSocket Monitor because:")
print("  1. Arbitrage windows are typically < 1 second")
print("  2. Real-time data = better decision making")
print("  3. Data logging enables backtesting and analysis")
print("  4. Lower API usage = fewer rate limit issues")
print("  5. Professional trading requires real-time data")
print()
print("="*80)
print()
print("To run:")
print("  Polling:   python src/price_monitor.py")
print("  WebSocket: python run_websocket_monitor.py")
print()
